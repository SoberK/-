## 说一下React生命周期

**三个阶段：**

1. 挂载时: 首次实例化组件被挂载时，主要的生命周期有：constructor, render,componentDidMount
2. 更新时: 当组件的props或者state 更新时执行， componentDidUpdate和一个静态方法，返回最新的state
3. 卸载时: 当组件卸载或销毁时，componentsWillUnmount



## React Hooks

**useState:** 接受一个初始值返回一个新的state和一个更新state的函数。

**useEffect:** 接受两个参数，一个包含命令式和有可能有副作用代码的函数以及一个依赖值数组。 执行时机：在浏览器绘制之后并且保证在任何新的渲染之前执行。如果想在绘制之前执行可以使用useLayoutEffect代替

**useContext:** 接受一个context对象（Racet.creatContext返回值）返回该context的当前值。

额外的Hooks(如下)：大多数是useState和useEffect的变体，在某些特殊情况下用起来更好。

**useReducer:** 类似于redux机制，接受一个reducer和一个initialState,返回一个state和dispatch方法。 在某些场景下代替uesState，比如：state逻辑复杂并且包含多个子值，或者下一个state依赖于上一个state.

**useMemo和uesCallback:** 作用：用法类似都是用于减少渲染次数，达到优化性能的作用。 useMemo(() => fn, [deps]) = useCallback(fn, [deps]) 他们唯一的区别是：useCallback是根据依赖项（deps）缓存第一个参数callback。useMemo是根据依赖项（deps）缓存第一个参数callback执行后的值。



## 说一下虚拟DOM

虚拟dom本质就是一个JS对象，虚拟dom存在的唯一的意义在于最小化dom改变，然后批处理dom变化，在必要的时候在重新渲染页面

**diff 分为三类比较：**

1.相同类型节点比较：只会对属性进行重设，从而实现节点的转变

2.不同类型节点比较：会直接删除旧的节点，创建新的节点代替。

3.列表节点比较：开发手动添加key,帮助react定位到正确的节点，减少dom操作次数。



## 单项数据流

**我所理解的单项数据流是**：数据是不可逆的，父组件向子组件通过props传递数据，子组件不可修改props, 只能通过触发事件通知父组件修改数据，在派发给子组件。



### 为什么 0.1 + 0.2 不等于 0.3

与许多其他编程语言不同，JavaScript 并未定义不同类型的数字数据类型，而是始终遵循国际 IEEE 754 标准，将数字存储为`双精度浮点数`。

这种格式以 64 位存储数字，其中`数字（分数）存储在位 0 到 51 中`，指数存储在位 52 到 62 中，符号存储在位 63 中。

用科学计数法表示二进制 0.1 并只保留前 52 位



### 1. HTTP 和 HTTPS 

#### 1.http 和 https 的基本概念

http:http是服务器与客户端请求的一个应答标准Tcp,用于从www服务器传输超文本到本地浏览器的超文本传输协议

Https：https:是以安全为目标的 HTTP 通道，即 HTTP 下 加入 SSL 层进行加密。其作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。

#### 2.http 和 https 的区别及优缺点？

+ http:80端口，https:443
+ Https 需要ca证书，
+ http是明文传输，https是加密传输】
+ https需要握手比较费时
+ https缓存不如http高效

#### 3.https 协议的工作原理

+ 客户端使用 https url 访问服务器，则要求 web 服务器`建立 ssl 链接`。
+ web 服务器接收到客户端的请求之后，会`将网站的证书（证书中包含了公钥），传输给客户端`。
+ 客户端和 web 服务器端开始`协商 SSL 链接的安全等级`，也就是加密等级。
+ 客户端浏览器通过双方协商一致的安全等级，`建立会话密钥`，然后通过网站的公钥来加密会话密钥，并传送给网站。
+ web 服务器`通过自己的私钥解密出会话密钥`。
+ web 服务器`通过会话密钥加密与客户端之间的通信`。



### TCP和UDP的区别TCP是面向`链接`的，而UDP是面向无连接的。

+ TCP仅支持`单播传输`，UDP 提供了单播，多播，广播的功能。
+ TCP是面向`链接`的，而UDP是面向无连接的。

+ TCP的三次握手保证了连接的`可靠性`; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。

+ UDP的`头部开销`比TCP的更小，数据`传输速率更高`，`实时性更好`。

  

### Cookie、sessionStorage、localStorage 的区别

**相同点**：

- 存储在客户端

**不同点**：

- cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+
- cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除
- cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地

### 从输入URL到页面加载的全过程

1、首先在浏览器中输入URL

2、查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则显示页面内容。如果没有则进行下一步。

- 浏览器缓存：浏览器会记录DNS一段时间，因此，只是第一个地方解析DNS请求；
- 操作系统缓存:如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统， 获取操作系统的记录(保存最近的DNS查询缓存)；
- 路由器缓存：如果上述两个步骤均不能成功获取DNS记录，继续搜索路由器缓存；
- ISP缓存：若上述均失败，继续向ISP搜索。

3、DNS域名解析：浏览器向DNS服务器发起请求，解析该URL中的域名对应的IP地址。`DNS服务器是基于UDP的，因此会用到UDP协议`。

4、建立TCP连接：解析出IP地址后，根据IP地址和默认80端口，和服务器建立TCP连接

5、发起HTTP请求：浏览器发起读取文件的HTTP请求，，该请求报文作为TCP三次握手的第三次数据发送给服务器

6、服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的html文件发送给浏览器

7、关闭TCP连接：通过四次挥手释放TCP连接

8、浏览器渲染：客户端（浏览器）解析HTML内容并渲染出来，浏览器接收到数据包后的解析流程为：

- 构建DOM树：词法分析然后解析成DOM树（dom tree），是由dom元素及属性节点组成，树的根是document对象
- 构建CSS规则树：生成CSS规则树（CSS Rule Tree）
- 构建render树：Web浏览器将DOM和CSSOM结合，并构建出渲染树（render tree）
- 布局（Layout）：计算出每个节点在屏幕中的位置
- 绘制（Painting）：即遍历render树，并使用UI后端层绘制每个节点。

9、JS引擎解析过程：调用JS引擎执行JS代码（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）



### 浏览器重绘与重排的区别？

- `重排/回流（Reflow）`：当`DOM`的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。表现为重新生成布局，重新排列元素。
- `重绘(Repaint)`: 当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变



### 如何触发重排和重绘？

任何改变用来构建渲染树的信息都会导致一次重排或重绘：

- 添加、删除、更新DOM节点

- 通过display: none隐藏一个DOM节点-触发重排和重绘

- 通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化

- 移动或者给页面中的DOM节点添加动画

- 添加一个样式表，调整样式属性

- 用户行为，例如调整窗口大小，改变字号，或者滚动。

  

### 如何避免重绘或者重排？

1. `集中改变样式`，不要一条一条地修改 DOM 的样式。
2. 不要把 DOM 结点的属性值放在循环里当成循环里的变量。
3. 为动画的 HTML 元件使用 `fixed` 或 `absoult` 的 `position`，那么修改他们的 CSS 是不会 reflow 的。
4. 不使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。
5. 尽量只修改`position：absolute`或`fixed`元素，对其他元素影响不大
6. 动画开始`GPU`加速，`translate`使用`3D`变化
7. 提升为合成层



