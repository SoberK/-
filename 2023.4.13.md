### 作用域和闭包

> 什么是作用链

当访问一个变量时，解释器会首先在当前作用域中查找标识符，如果没找到，就去父作用域找，直到找到该变量的标识符或没找到为止。这条寻找的链路就叫作用域链



> 什么是闭包

在JavaScript中，根据词法作用域的规则，内部函数总是可以访问其外部函数当中声明的变量；当调用通过外部函数返回的内部函数时，即使此时外部函数已经执行结束，但是内部函数所引用外部函数的变量依然保存在内存中，我们把这些变量的集合称为闭包



> 闭包怎么产生的

当函数存在对其所在词法作用域的引用，而该函数被拿到当前词法作用域外执行，此时就产生了闭包。



> 在工作中，哪些地方使用到了闭包

+ return 一个函数
+ 函数作为参数
+ IIFE自执行函数



> 为什么要使用闭包？/ 闭包的好处？

+ 保护函数的私有变量不受外部干扰。形成不销毁的栈内存
+ 把一些函数内的值保存下来。闭包可以实现方法和属性的私有化



> 闭包变量怎么回收呢？

- 如果是全局变量被作为闭包变量的话，则该闭包变量会一直保存到页面关闭。（因为全局上下文会一直存在，不会被回收，除非页面关闭）

- 如果是局部变量被作为闭包变量的话，下面分两种情况讨论

  - 立马执行时会自动回收

    ```javascript
    function a(){
    　　var b= 10;
    　　return function(){
    　　　　b++;
    　　　　console.log(num);
    　　}
    }
    a()(); //11
    a()(); //11
    ```

  - 不回立马被执行

    ```javascript
    function a(){
        var b = 0;
        return function(){
            b ++;
            console.log(b);
        }
    }
    var d = a();
    d();//1
    d();//2
    ```

    

## JS数据类型

+ 原始值：
  + string
  + number
  + boolean
  + undefined
  + null
  + symbol
  + Bigint

+ 引用类型
  + OBject
  + Array
  + RegExp
  + Date
  + Math
  + Function



主要说下bitint,bigint是Es2020出现的，主要弥补number的精度丢失的异常，再最后使用n，来标识，也可用BigInt方法来写的

```javascript
const s = 12312312312312n
const s = BigInt(12312312312312)
```



## JS类型判断

+ typeof
+ instanceof 所有引用类型，
+ Object.prototype.toString.call() 判断浏览器内置对象
+ Constructor 对number和null无效



## JS的深拷贝和浅拷贝的方法

+ Object.assign(目标对象,源对象)
+ [...arr]
+ Array.protype.concat()
+ JSON.parse(JSON.stringify())
+ concat
+ slice



## this的指向问题

+ 默认调用，指向window

+ 对象调用，指向该对象

+ 做构造函数使用，指向实例对象

+ 箭头函数，执行函数所在的作用域

+ Call,apply,bind指向传入的第一个参数

  ```javascript
  function a(pa,pb){
  	console.log(pa)
  	console.log(pb)
  }
  a.call(this,'1',2)
  a.apply(this,['1',2])
  a.bind(this,'1',2) //和call差不多，但是不会执行
  ```

  

## JS原型和原型链

> 什么事原型对象

 每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型对象，每一个对象都会从原型"继承"属性。



> 函数的原型和对象的原型：

- 每个函数都有一个prototype属性，该属性指向函数的原型

- 每个对象都有一个__proto__属性，该属性指向对象的原型

  

> 什么是原型链

当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。这条查找的路径就叫原型链



## js中的垃圾回收机制

> 什么是内存泄漏



内存是运行时操作系统分配给浏览器的内存空间，对于正在运行的内存需要及时释放，如果不及时释放，内存会越来越高，轻则影响系统性能，重则导致进程崩溃。不在使用的内存没有及时释放，就叫做内存泄漏。

影响内存泄漏的原因

+ 全局的声明变量，解决：使用var let、const
+ 忘记关闭的定时器
+ 使用闭包



> 垃圾回收机制

+ 标记清除

  垃圾回收程序运行的时候，会标记内存中存储的所有变量。然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次**内存清理**，销毁带标记的所有值并收回它们的内存。

+ 引用计数

​	另一种**没那么常用的**垃圾回收策略是**引用计数**（referencecounting）。其思路是对每个值都记录它被引用的次数。声明量	并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值	引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地	收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。但是会有循环引用的问题，导出出现bug.

