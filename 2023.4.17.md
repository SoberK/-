## 说说你对 XSS 的了解

英文全称是 `Cross Site Script`，`XSS`攻击可以分为3类：反射型（非持久型）、存储型（持久型）、基于`DOM XSS`

反射线：通过用户的输入的信息反射给浏览器。黑客往往需要诱使用户“点击”一个恶意链接，才能攻击成功，通常反射型`XSS`的恶意代码存在`URL`里，通过`URL`传递参数的功能，如网站搜索、跳转等

存储型:存储型 `XSS` 会把用户输入的数据“存储”在服务器端,比如表单中写入js,当渲染页面执行的时候，遇到script标签就会执行输入的脚本

基于`DOM XSS`：实际上，这种类型的`XSS`并非按照“数据是否保存在服务器端”来划分，`DOM Based XSS`从效果上来说也是反射型`XSS`。单独划分出来，是因为`DOM Based XSS` 的形成原因比较特别，发现它的安全专家专门提出了这种类型的`XSS`。`DOM 型 XSS`跟前两种`XSS`的区别：`DOM 型 XSS`攻击中，取出和执行恶意代码由浏览器端完成，属于前端`JavaScript`自身的安全漏洞，而其他两种`XSS`都属于服务端的安全漏洞。



## `XSS`攻击防御

+ HttpOnly`
+ 输入检查 ：在`XSS`的防御上，输入检查一般是检查用户输入的数据中是否包含一些特殊字符，如`＜、＞、’、”`，做转义
+ 输出检查：和输入一样，转义





## 说说css模块化的理解

- 手写源生 CSS
- 使用预处理器 Sass/Less
  - 预处理器主要是强化了 css 的语法，弥补了上文说了这些问题，但本质上，打包出来的结果和源生的 css 都是一样的，只是对开发者友好，写起来更顺滑。
- 使用后处理器 PostCSS
  - 配合 stylelint 校验 css 语法
  - 自动增加浏览器前缀 autoprefixer
  - 编译 css next 的语法
- 使用 css modules
  - 随着 react、vue 等基于模块化的框架的普及使用，我们编写源生 css 的机会也越来越少。我们常常将页面拆分成许多个小组件，然后像搭积木一样将多个小组件组成最终呈现的页面。



## 什么是作用域链？

我们一般将作用域分成：

- 全局作用域：任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问
- 函数作用域：函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问
- 块级作用域：ES6引入了`let`和`const`关键字,和`var`关键字不同，在大括号中使用`let`和`const`声明的变量存在于块级作用域中。在大括号之外不能访问这些变量
- 

## 说说你对函数式编程的理解，以及优缺点？

主要的编程范式有三种：命令式编程，声明式编程和函数式编程

+ 高阶函数：函数作为参数
+ 纯函数：没有副作用
+ 柯里化：多元函数转为一元函数的过程，
  + 关于柯里化函数的意义如下：
    + 让纯函数更纯，每次接受一个参数，松散解耦
    + 惰性执行

#### 优点

- 更好的管理状态：因为它的宗旨是无状态，或者说更少的状态，能最大化的减少这些未知、优化代码、减少出错情况
- 更简单的复用：固定输入->固定输出，没有其他外部变量影响，并且无副作用。这样代码复用时，完全不需要考虑它的内部实现和外部影响
- 更优雅的组合：往大的说，网页是由各个组件组成的。往小的说，一个函数也可能是由多个小函数组成的。更强的复用性，带来更强大的组合性
- 隐性好处。减少代码量，提高维护性

#### 缺点：

- 性能：函数式编程相对于指令式编程，性能绝对是一个短板，因为它往往会对一个方法进行过度包装，从而产生上下文切换的性能开销
- 资源占用：在 JS 中为了实现对象状态的不可变，往往会创建新的对象，因此，它对垃圾回收所产生的压力远远超过其他编程方式
- 递归陷阱：在函数式编程中，为了实现迭代，通常会采用递归操作





## 怎么实现图片懒加载？

懒加载的作用：

1. 全部加载的话会影响用户体验
2. 浪费用户的流量，有些用户并不想全部看完，全部加载会耗费大量流量。

最简单的实现方式是给 `img` 标签加上 `loading="lazy"`，比如

也可以通过滚动来实现加载

第三方的库